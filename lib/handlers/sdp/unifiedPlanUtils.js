const Logger = require('../../Logger');
const logger = new Logger('LPZ Client UnifiedPlanUtils');

/**
 * Get RTP encodings.
 *
 * @param {Object} offerMediaObject - Local SDP media Object generated by sdp-transform.
 *
 * @returns {Array<RTCRtpEncodingParameters>}
 */
exports.getRtpEncodings = function({ offerMediaObject })
{
	logger.debug('getRtpEncodings, [offerMediaObject:%o]', offerMediaObject);
	const ssrcs = new Set();

	for (const line of offerMediaObject.ssrcs || [])
	{
		const ssrc = line.id;

		ssrcs.add(ssrc);
	}

	logger.debug('getRtpEncodings, [ssrcs:%o]', ssrcs);

	if (ssrcs.size === 0)
		throw new Error('no a=ssrc lines found');

	const ssrcToRtxSsrc = new Map();

	// First assume RTX is used.
	for (const line of offerMediaObject.ssrcGroups || [])
	{
		if (line.semantics !== 'FID')
			continue;

		let [ ssrc, rtxSsrc ] = line.ssrcs.split(/\s+/);

		ssrc = Number(ssrc);
		rtxSsrc = Number(rtxSsrc);

		if (ssrcs.has(ssrc))
		{
			// Remove both the SSRC and RTX SSRC from the set so later we know that they
			// are already handled.
			ssrcs.delete(ssrc);
			ssrcs.delete(rtxSsrc);

			// Add to the map.
			ssrcToRtxSsrc.set(ssrc, rtxSsrc);
		}
	}
	logger.debug('getRtpEncodings, 1 [ssrcToRtxSsrc:%o]', ssrcToRtxSsrc);

	// If the set of SSRCs is not empty it means that RTX is not being used, so take
	// media SSRCs from there.
	for (const ssrc of ssrcs)
	{
		// Add to the map.
		ssrcToRtxSsrc.set(ssrc, null);
	}
	logger.debug('getRtpEncodings, 2 [ssrcToRtxSsrc:%o]', ssrcToRtxSsrc);

	const encodings = [];

	for (const [ ssrc, rtxSsrc ] of ssrcToRtxSsrc)
	{
		const encoding = { ssrc };

		if (rtxSsrc)
			encoding.rtx = { ssrc: rtxSsrc };

		encodings.push(encoding);
	}

	logger.debug('getRtpEncodings, return [encodings:%o]', encodings);
	return encodings;
};

/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 *
 * @param {Object} offerMediaObject - Local SDP media Object generated by sdp-transform.
 * @param {Number} numStreams - Number of simulcast streams.
 */
exports.addLegacySimulcast = function({ offerMediaObject, numStreams })
{
	logger.debug('addLegacySimulcast, [offerMediaObject:%o, numStreams:%o]', offerMediaObject, numStreams);
	if (numStreams <= 1)
		throw new TypeError('numStreams must be greater than 1');

	// Get the SSRC.
	const ssrcMsidLine = (offerMediaObject.ssrcs || [])
		.find((line) => line.attribute === 'msid');

	logger.debug('addLegacySimulcast, [ssrcMsidLine:%o]', ssrcMsidLine);
	if (!ssrcMsidLine)
		throw new Error('a=ssrc line with msid information not found');

	const [ streamId, trackId ] = ssrcMsidLine.value.split(' ')[0];
	const firstSsrc = ssrcMsidLine.id;
	let firstRtxSsrc;

	logger.debug('addLegacySimulcast, [streamId:%o, trackId:%o]', streamId, trackId);

	// Get the SSRC for RTX.
	(offerMediaObject.ssrcGroups || [])
		.some((line) =>
		{
			if (line.semantics !== 'FID')
				return;

			const ssrcs = line.ssrcs.split(/\s+/);

			if (Number(ssrcs[0]) === firstSsrc)
			{
				firstRtxSsrc = Number(ssrcs[1]);

				return true;
			}
		});

	const ssrcCnameLine = offerMediaObject.ssrcs
		.find((line) => line.attribute === 'cname');

	logger.debug('addLegacySimulcast, [ssrcCnameLine:%o, offerMediaObject:%o]', ssrcCnameLine, offerMediaObject);
	if (!ssrcCnameLine)
		throw new Error('a=ssrc line with cname information not found');

	const cname = ssrcCnameLine.value;
	const ssrcs = [];
	const rtxSsrcs = [];

	for (let i = 0; i < numStreams; ++i)
	{
		ssrcs.push(firstSsrc + i);

		if (firstRtxSsrc)
			rtxSsrcs.push(firstRtxSsrc + i);
	}
	logger.debug('addLegacySimulcast, [ssrcs:%o, rtxSsrcs:%o]', ssrcs, rtxSsrcs);

	offerMediaObject.ssrcGroups = [];
	offerMediaObject.ssrcs = [];

	offerMediaObject.ssrcGroups.push(
		{
			semantics : 'SIM',
			ssrcs     : ssrcs.join(' ')
		});

	for (let i = 0; i < ssrcs.length; ++i)
	{
		const ssrc = ssrcs[i];

		offerMediaObject.ssrcs.push(
			{
				id        : ssrc,
				attribute : 'cname',
				value     : cname
			});

		offerMediaObject.ssrcs.push(
			{
				id        : ssrc,
				attribute : 'msid',
				value     : `${streamId} ${trackId}`
			});
	}

	for (let i = 0; i < rtxSsrcs.length; ++i)
	{
		const ssrc = ssrcs[i];
		const rtxSsrc = rtxSsrcs[i];

		offerMediaObject.ssrcs.push(
			{
				id        : rtxSsrc,
				attribute : 'cname',
				value     : cname
			});

		offerMediaObject.ssrcs.push(
			{
				id        : rtxSsrc,
				attribute : 'msid',
				value     : `${streamId} ${trackId}`
			});

		offerMediaObject.ssrcGroups.push(
			{
				semantics : 'FID',
				ssrcs     : `${ssrc} ${rtxSsrc}`
			});
	}
	logger.debug('addLegacySimulcast, [offerMediaObject:%o]', offerMediaObject);
};
